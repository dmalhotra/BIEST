#ifndef _BIE_SOLVERS_HPP_
#define _BIE_SOLVERS_HPP_

#include <biest/boundary_integ_op.hpp>
#include <biest/surface_op.hpp>
#include <biest/surface.hpp>
#include <sctl.hpp>

namespace biest {

/**
 * Compute vacuum magnetic field enclosed within one toroidal surface or
 * between two toroidal surfaces.
 *
 * @tparam Real datatype for reals can be float, double or sctl::QuadReal.
 *
 * @tparam UPSAMPLE source mesh upsample factor for boundary quadratures.
 *
 * @tparam PATCH_DIM0 the partition of unity function is defined on a grid of
 * dimensions PATCH_DIM0 x PATCH_DIM0.
 *
 * @tparam RAD_DIM the order of the polar quadrature rule. Radial dimension is
 * RAD_DIM and angular dimension is 2*RAD_DIM
 */
template <class Real, sctl::Integer UPSAMPLE = 1, sctl::Integer PATCH_DIM0 = 24, sctl::Integer RAD_DIM = 35> class VacuumField {
    static constexpr sctl::Integer COORD_DIM = 3;

  public:

    /**
     * Compute the vacuum magnetic field (on surface) and surface currents
     * which produce this field.
     *
     * @param[out] B the magnetic field on the surface.  B = {Bx11, Bx12, ...,
     * Bx1Np, Bx21, Bx22, ... , BxNtNp, By11, ... , Bz11, ...}, where Nt and Np
     * are the number of discretizations in toroidal and poloidal directions.
     *
     * @param[out] J the surface currents.  J = {Jx11, Jx12, ..., Jx1Np, Jx21,
     * Jx22, ... , JxNtNp, Jy11, ... , Jz11, ...}, where Nt and Np are the
     * number of discretizations in toroidal and poloidal directions.
     *
     * @param[in] tor_flux the toroidal flux.
     *
     * @param[in] pol_flux the poloidal flux (for toridal shells).
     *
     * @param[in] Svec vector for surfaces. The vector dimension can be 1 or 2.
     * @see biest::Surface
     * @see sctl::Vector
     *
     * @param[in] comm the communicator when running in parallel.
     *
     * @param[in] gmres_tol the tolerance for the GMRES linear solve.
     *
     * @param[in] gmres_iter the maximum number of GMRES iterations.
     */
    static void Compute(sctl::Vector<Real>& B, sctl::Vector<Real>& J, Real tor_flux, Real pol_flux, const sctl::Vector<Surface<Real>>& Svec, const sctl::Comm& comm, Real gmres_tol, sctl::Long gmres_iter);

    /**
     * Compute the vacuum magnetic field generated by given surface currents at
     * off-surface points.
     *
     * @param[out] Btrg the magnetic field at target points.  Btrg = {Bx1, By1,
     * Bz1, Bx2, By2, ..., BxN, ByN, BzN}. Where N is the number of target
     * points.
     *
     * @param[in] Xtrg the location of the target points.  Xtrg = {x1, y1, z1,
     * x2, y2, ..., xN, yN, zN}. Where N is the number of target points.
     *
     * @param[in] Svec vector for surfaces. The vector dimension can be 1 or 2.
     * @see biest::Surface
     * @see sctl::Vector
     *
     * @param[in] J0 the surface currents.  J0 = {Jx11, Jx12, ..., Jx1Np, Jx21,
     * Jx22, ... , JxNtNp, Jy11, ... , Jz11, ...}, where Nt and Np are the
     * number of discretizations in toroidal and poloidal directions.
     *
     * @param[in] comm the communicator when running in parallel.
     */
    static void EvalOffSurface(sctl::Vector<Real>& Btrg, const sctl::Vector<Real>& Xtrg, sctl::Vector<Surface<Real>> Svec, sctl::Vector<Real> J0, const sctl::Comm& comm);

    /**
     * A simple subroutine to test this class.
     */
    static void test(sctl::Long upsample, const sctl::Comm& comm);

  private:

    static Real max_norm(const sctl::Vector<Real>& x);

    static void ComputeFarField(sctl::Vector<Real>& B, const sctl::Vector<Real>& Xt, const sctl::Vector<sctl::Vector<Real>>& Xsrc, const sctl::Vector<sctl::Vector<Real>>& Xn_src, const sctl::Vector<sctl::Vector<Real>>& J);

    static void ComputeHelper(sctl::Vector<sctl::Vector<Real>>& B, sctl::Vector<sctl::Vector<Real>>& J, sctl::Vector<Real>& tor_flux, sctl::Vector<Real>& pol_flux, const sctl::Vector<Surface<Real>>& Svec, const sctl::Comm& comm, Real gmres_tol, sctl::Long gmres_iter);
};

/**
 * Compute Taylor states magnetic field enclosed within one toroidal surface or
 * between two toroidal surfaces.
 *
 * @tparam Real datatype for reals can be float, double or sctl::QuadReal.
 *
 * @tparam UPSAMPLE source mesh upsample factor for boundary quadratures.
 *
 * @tparam PATCH_DIM0 the partition of unity function is defined on a grid of
 * dimensions PATCH_DIM0 x PATCH_DIM0.
 *
 * @tparam RAD_DIM the order of the polar quadrature rule. Radial dimension is
 * RAD_DIM and angular dimension is 2*RAD_DIM
 */
template <class Real, sctl::Integer UPSAMPLE = 1, sctl::Integer PATCH_DIM0 = 24, sctl::Integer RAD_DIM = 35> class TaylorState {
    static constexpr sctl::Integer COORD_DIM = 3;

  public:

    /**
     * Compute the Taylor state magnetic field (on surface) and optionally the
     * generalized Debye source densities.  which produce this field.
     *
     * @param[out] B the magnetic field on the surface.  B = {Bx11, Bx12, ...,
     * Bx1Np, Bx21, Bx22, ... , BxNtNp, By11, ... , Bz11, ...}, where Nt and Np
     * are the number of discretizations in toroidal and poloidal directions.
     *
     * @param[in] tor_flux the toroidal flux.
     *
     * @param[in] pol_flux the poloidal flux (for toridal shells).
     *
     * @param[in] lambda the Taylor state parameter lambda.
     *
     * @param[in] Svec vector for surfaces. The vector dimension can be 1 or 2.
     * @see biest::Surface
     * @see sctl::Vector
     *
     * @param[in] comm the communicator when running in parallel.
     *
     * @param[in] gmres_tol the tolerance for the GMRES linear solve.
     *
     * @param[in] gmres_iter the maximum number of GMRES iterations.
     *
     * @param[in] LB_tol the GMRES tolerance for the Laplace-Beltrami solve is
     * LB_tol*gmres_tol/lambda.
     *
     * @param[out] m the generalized Debye source density m.  m = {mx11, mx12,
     * ..., mx1Np, mx21, mx22, ... , mxNtNp, my11, ... , mz11, ...}, where Nt
     * and Np are the number of discretizations in toroidal and poloidal
     * directions.
     *
     * @param[out] sigma the generalized Debye source density sigma.  sigma = {sigma11, sigma12,
     * ..., sigma1Np, sigma21, sigma22, ... , sigmaNtNp}, where Nt and Np are
     * the number of discretizations in toroidal and poloidal directions.
     */
    static void Compute(sctl::Vector<Real>& B, Real tor_flux, Real pol_flux, Real lambda, const sctl::Vector<Surface<Real>>& Svec, const sctl::Comm& comm, Real gmres_tol, sctl::Long gmres_iter, Real LB_tol = 0.1, sctl::Vector<sctl::Vector<Real>>* m = nullptr, sctl::Vector<sctl::Vector<Real>>* sigma = nullptr);

    /**
     * Evaluate the Taylor states field (generated by given generalize Debye
     * source densities) at off-surface points.
     *
     * @param[out] Btrg the magnetic field at target points.  Btrg = {Bx1, By1,
     * Bz1, Bx2, By2, ..., BxN, ByN, BzN}. Where N is the number of target
     * points.
     *
     * @param[in] Xtrg the location of the target points.  Xtrg = {x1, y1, z1,
     * x2, y2, ..., xN, yN, zN}. Where N is the number of target points.
     *
     * @param[in] Svec vector for surfaces. The vector dimension can be 1 or 2.
     * @see biest::Surface
     * @see sctl::Vector
     *
     * @param[in] tor_flux the toroidal flux.
     *
     * @param[in] pol_flux the poloidal flux (for toridal shells).
     *
     * @param[in] lambda the Taylor state parameter lambda.
     *
     * @param[out] m the generalized Debye source density m.  m = {mx11, mx12,
     * ..., mx1Np, mx21, mx22, ... , mxNtNp, my11, ... , mz11, ...}, where Nt
     * and Np are the number of discretizations in toroidal and poloidal
     * directions.
     *
     * @param[out] sigma the generalized Debye source density sigma.  sigma = {sigma11, sigma12,
     * ..., sigma1Np, sigma21, sigma22, ... , sigmaNtNp}, where Nt and Np are
     * the number of discretizations in toroidal and poloidal directions.
     *
     * @param[in] comm the communicator when running in parallel.
     */
    static void EvalOffSurface(sctl::Vector<Real>& Btrg, const sctl::Vector<Real>& Xtrg, sctl::Vector<Surface<Real>> Svec, Real tor_flux, Real pol_flux, Real lambda, const sctl::Vector<sctl::Vector<Real>> m, const sctl::Vector<sctl::Vector<Real>>& sigma, const sctl::Comm& comm);

    /**
     * Test this class.
     */
    static void test_conv(Real lambda, const sctl::Vector<Surface<Real>>& Svec_, sctl::Long upsample, Real gmres_tol, sctl::Long gmres_iter, const sctl::Comm& comm, Real LB_tol = 0.1);

  private:

    static Real max_norm(const sctl::Vector<Real>& x);

    static void ComputeFarField(sctl::Vector<Real>& Breal, const sctl::Vector<Real>& Xt, const sctl::Vector<sctl::Vector<Real>>& Xsrc, const sctl::Vector<sctl::Vector<Real>>& Xn_src, const sctl::Vector<sctl::Vector<Real>>& sigma, const sctl::Vector<sctl::Vector<Real>>& m, Real lambda);

    static void Compute_mH(sctl::Vector<Real>& mH, const Surface<Real>& S, const sctl::Vector<Real>& dX, const sctl::Vector<Real>& Xn, const sctl::Comm& comm, Real tol, sctl::Long max_iter);
    static void Compute_Grad_v(sctl::Vector<Real>& Grad_v, const sctl::Vector<Real>& sigma, const BoundaryIntegralOp<Real,2,6,UPSAMPLE,PATCH_DIM0,RAD_DIM>& BI_grad, const KernelFunction<Real,COORD_DIM,2,COORD_DIM*2>& ker_grad); // grad_v <-- Grad(g[sigma])
    static void Compute_iQ(sctl::Vector<Real>& iQ, const sctl::Vector<Real>& m, const sctl::Vector<sctl::Long>& SurfDim, const sctl::Vector<sctl::Long>& SurfDsp, const BoundaryIntegralOp<Real,2,2,UPSAMPLE,PATCH_DIM0,RAD_DIM>& BI_potn, const KernelFunction<Real,COORD_DIM,2,2>& ker_potn, Real lambda); // iQ <-- i g[m]
    static void Compute_iCurlQ(sctl::Vector<Real>& iCurlQ, const sctl::Vector<Real>& m, const sctl::Vector<sctl::Long>& SurfDim, const sctl::Vector<sctl::Long>& SurfDsp, const BoundaryIntegralOp<Real,2,6,UPSAMPLE,PATCH_DIM0,RAD_DIM>& BI_grad, const KernelFunction<Real,COORD_DIM,2,COORD_DIM*2>& ker_grad); // iCurlQ <-- i Curl(g[m])

    static void ComputeHelper(sctl::Vector<sctl::Vector<Real>>& B_out, sctl::Vector<sctl::Vector<Real>>& m_out, sctl::Vector<sctl::Vector<Real>>& sigma_out, Real lambda, const sctl::Vector<Surface<Real>>& Svec, const sctl::Comm& comm, Real gmres_tol, sctl::Long gmres_iter, Real LB_tol = 0.1);
};

}

#include <biest/bie_solvers.txx>

#endif  //_BIE_SOLVERS_HPP_
